<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/04/%E7%94%A8%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/12/04/%E7%94%A8%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 用前序和中序构造二叉树<br>date: 2023-12-04 09:36:33<br>tags:<br>  众所周知，需要至少两种遍历方式才可以确定一颗二叉树的，今天就让我们采用前序和中序遍历的方法构造二叉树。</p><p>  我们以例题的形式进行讲解：给定两个数组：pre&#x3D;{A,B,D,E,C,F,G}，in&#x3D;{D,B,E,A,C,G,F};<br>我们先用先序遍历对preorder进行构造，A为根节点毋庸置疑，根据我们人来观察发现{B,D,E}为左子树，{C，F，G}为右子树，那么计算机应该怎样来识别呢？<br>通过观察分析不难发现：在inorder序列里面，第一个与preorder的第一个字符A相等时，其前面的字符都为左子树，后面的都为右子树，那么把左子树的字符提出来在用同样的方法进行操作，即用迭代的方式就构建出了左子树。右子树的构造方法同理。以下是具体的代码实现：</p><p>&#x2F;&#x2F;创建结构体<br>typedef struct node{<br>    int data;<br>    struct node *leftchild,*rightchild;<br>}Binode,*Bitree;</p><p>int pre[maxn];<br>int in[maxn];</p><p>&#x2F;&#x2F;构造二叉树<br>Bitree create(int prel,int prer,int inl,int inr)&#x2F;&#x2F;prel和prer分别表示前序序列中检测的左右边界，inl和inr分别表示inorder序列中检测的左右边界<br>{<br>    if(prel&gt;prer)return;&#x2F;&#x2F;退出条件<br>    Bitree root&#x3D;(Bitree)malloc(sizeof(Bitnode));<br>    &#x2F;&#x2F;Bitree&#x3D;new Bitnode;<br>    root-&gt;data&#x3D;pre[prel];&#x2F;&#x2F;依次构造<br>    int i&#x3D;0;<br>    for(i&#x3D;inl;i&lt;&#x3D;inr;i++)<br>    {<br>        if(in[i]&#x3D;&#x3D;pre[prel])break;&#x2F;&#x2F;找到左右子树在pre序列里的检测边界<br>    }<br>    int num&#x3D;i-inl;&#x2F;&#x2F;检测个数<br>    &#x2F;&#x2F;迭代构造左右子树<br>    root-&gt;leftchild&#x3D;create(prel+1,prel+num,inl,i-1);&#x2F;&#x2F;左子树<br>    root-&gt;rightchild&#x3D;create(prel+num+1,prer,i+1,inr);&#x2F;&#x2F;右子树<br>    return root;<br>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Opengl 的贝塞尔曲线绘制</title>
    <link href="/2023/11/20/index/"/>
    <url>/2023/11/20/index/</url>
    
    <content type="html"><![CDATA[<p>计算机图形学绘制贝塞尔曲线真的是难绷，那个用鼠标拖动始终完成不了，先立个flag在这里，我两天之内一定要解决这个问题，先把现在的代码存在这里：<br>“头文件”<br>“#pragma once<br>#define MAX_OBJECTS 10000<br>#define DEFAULT_POINT_SIZE 10<br>#define DEFAULT_LINE_WIDTH 5<br>#define DEFAULT_BEZIER_CONTROL_POINTS_NUM 4<br>#define MAX_BEZIER_CONTROL_POINTS_NUM 13<br>#define DEFAULT_PICK_BUFFER_SIZE 32<br>#define DEFAULT_PICK_WINDOW_SIZE 10<br>#define MAX_BEZIER_LINE_NUM 5<br>#define PI 3.14159265358979323846 &#x2F;&#x2F; pi<br>#include&lt;stdio.h&gt;<br>#include&lt;math.h&gt;<br>#include&lt;GL&#x2F;glut.h&gt;<br>#include&lt;GL&#x2F;glu.h&gt;<br>#include&lt;GL&#x2F;gl.h&gt;<br>struct GLTransform;<br>struct GLWorld;<br>enum GLState {<br>    MoveObject,<br>    MakePoint<br>};</p><p>struct GLColor<br>{<br>    GLfloat r &#x3D; 0, g &#x3D; 0, b &#x3D; 0;<br>};</p><p>struct GLTransform<br>{<br>    &#x2F;&#x2F; 世界坐标，轴旋转，轴缩放<br>    GLdouble x &#x3D; 0, y &#x3D; 0, z &#x3D; 0;<br>    GLdouble rx &#x3D; 0, ry &#x3D; 0, rz &#x3D; 0;<br>    GLdouble sx &#x3D; 1, sy &#x3D; 1, sz &#x3D; 1;<br>};<br>struct GLPoint {<br>    GLint id &#x3D; 0;<br>    GLColor color;<br>    GLTransform transform;<br>    bool movable &#x3D;true;<br>    bool visible &#x3D; true;</p><pre><code class="hljs">GLWorld* parentWorld;void SetPosition(GLdouble x, GLdouble y, GLdouble z) &#123;    transform.x = x;    transform.y = y;    transform.z = z;&#125;void Draw(GLenum RenderMode = GL_RENDER)&#123;    // 需要在绘制前调用 SetPostion，否则绘制在原点    if (!visible) return;    if (RenderMode == GL_SELECT) glLoadName((GLuint)id);    glColor3f(1, 0, 0);    glPointSize(DEFAULT_POINT_SIZE);    glBegin(GL_POINTS);    glVertex3d(transform.x, transform.y, transform.z);    glEnd();&#125;</code></pre><p>};<br>struct GLWorld<br>{<br>    GLPoint* objects[MAX_OBJECTS];<br>    GLint count &#x3D; 0;</p><pre><code class="hljs">GLPoint* CreatePt(GLdouble x, GLdouble y, GLdouble z) &#123;    if (count &lt; MAX_OBJECTS)    &#123;        GLPoint* ret = (GLPoint*)malloc(sizeof(GLPoint));        objects[count] = ret;        //objects[count]-&gt;parentWorld = this;        //objects[count]-&gt;id = count;        objects[count]-&gt;SetPosition(x, y, z);        ++count;        return ret;    &#125;    else return nullptr;&#125;void DeleteObject(GLint id)//根据 id 删除一个对象&#123;    for (int i = 0; i &lt; count; ++i) &#123;        if (objects[i]-&gt;id == id) &#123;            free(objects[i]);            objects[i] = nullptr;            // 将删除的对象后面的对象向前移动            for (int j = i; j &lt; count - 1; ++j) &#123;                objects[j] = objects[j + 1];            &#125;            objects[count - 1] = nullptr;            --count;            break;        &#125;    &#125;&#125;void Empty()//清空所有对象&#123;    for (int i = 0; i &lt; count; ++i) &#123;        free(objects[i]);        //objects[i] = nullptr;    &#125;    count = 0; &#125;void DrawObjects(GLenum RenderMode = GL_RENDER) &#123;    for (int i = 0; i &lt; count; ++i)    &#123;        if (!objects[i]) return;        objects[i]-&gt;Draw(RenderMode);    &#125;&#125;GLint pickedObjectId = -1;void PickObject(GLint xMouse, GLint yMouse) &#123;    pickRects(GLUT_LEFT_BUTTON, GLUT_DOWN, xMouse, yMouse);&#125;//void pickRects(GLint button, GLint action, GLint xMouse, GLint yMouse);//void processPicks(GLint nPicks, GLuint pickBuffer[]);GLuint pickBuffer[DEFAULT_PICK_BUFFER_SIZE];GLint nPicks, vpArray[4];</code></pre><p> GLfloat xwcMin, xwcMax, ywcMin, ywcMax;<br>    void processPicks(GLint nPicks, GLuint pickBuffer[])</p><pre><code class="hljs">&#123;    // 储存获取到的最后一个 ID，即认为后绘制的图像在先绘制的图形之上     if (nPicks == 0) pickedObjectId = -1;    else    &#123;        // 因为只使用一个栈顶元素，所以可以由公式计算得出最后一个图形 ID        int chunkId = 4 * (nPicks - 1);        pickedObjectId = pickBuffer[chunkId + 3];    &#125;    return;&#125;void pickRects(GLint button, GLint action, GLint xMouse, GLint yMouse)&#123;    GLuint pickBuffer[DEFAULT_PICK_BUFFER_SIZE];    GLint vpArray[4];    if (button != GLUT_LEFT_BUTTON || action != GLUT_DOWN)        return;    glSelectBuffer(DEFAULT_PICK_BUFFER_SIZE, pickBuffer); //  Designate pick buffer.    glRenderMode(GL_SELECT); // Activate picking operations.    glInitNames(); // Initialize the object￾ID stack.     // 只使用一个栈顶元素，后续为图形命名使用 glLoadName(id) 替换栈顶    glPushName(MAX_OBJECTS);    /* Save current viewing matrix. */    glMatrixMode(GL_PROJECTION);    glPushMatrix();    glLoadIdentity();    /* Obtain the parameters for the current viewport. Set up    75. * a 5 x 5 pick window, and invert the input yMouse value    76. * using the height of the viewport, which is the fourth    77. * element of vpArray.    78. */    glGetIntegerv(GL_VIEWPORT, vpArray);    gluPickMatrix(GLdouble(xMouse), GLdouble(yMouse), DEFAULT_PICK_WINDOW_SIZE, DEFAULT_PICK_WINDOW_SIZE, vpArray);    gluOrtho2D(xwcMin, xwcMax, ywcMin, ywcMax);    //rects (GL_SELECT); // Process the rectangles in selection mode.    this-&gt;DrawObjects(GL_SELECT);    /* Restore original viewing matrix. */    glMatrixMode(GL_PROJECTION);    glPopMatrix();    glFlush();    /* Determine the number of picked objects and return to the   94. * normal rendering mode.   95. */    nPicks =glRenderMode(GL_RENDER);    processPicks(nPicks, pickBuffer); // Process picked  objects.    glutPostRedisplay();&#125;</code></pre><p>};</p><p>struct GLBezierCtrlPts<br>{<br>    GLWorld* parentWorld;<br>    GLPoint* ctrlPoints[MAX_BEZIER_CONTROL_POINTS_NUM];<br>    int count &#x3D; 0;<br>    GLint nBezCurvePoints &#x3D; 1000;<br>    int currentCtrlPoints &#x3D; 0;<br>    &#x2F;&#x2F; Usage:<br>     &#x2F;&#x2F;GLWorld::NewObject<GLBezier>()-&gt;MakePoint(x,y,z);<br>    &#x2F;**&#x2F;<br>    void MakePoint(GLdouble x, GLdouble y, GLdouble z) {<br>        if (count &gt;&#x3D; MAX_BEZIER_CONTROL_POINTS_NUM) return;<br>        ctrlPoints[count] &#x3D; parentWorld-&gt;CreatePt(x, y, z);<br>        ctrlPoints[count]-&gt;SetPosition(x, y, z);<br>        ctrlPoints[count]-&gt;movable &#x3D; true;<br>        count++;<br>        currentCtrlPoints++;  &#x2F;&#x2F; 每次新增控制点时递增<br>    }<br>    void Draw(GLenum RenderMode &#x3D; GL_RENDER) {<br>        &#x2F;&#x2F; 需要在绘制前初始化控制点<br>        if (count &#x3D;&#x3D; 0) return;<br>        for (int i &#x3D; 0; i &lt; count; ++i)<br>        {<br>            if (!ctrlPoints[i]) return;<br>        }<br>        &#x2F;&#x2F;if (RenderMode &#x3D;&#x3D; GL_SELECT) glLoadName((GLuint)id);<br>        glColor3f(0.0, 0.0, 0.0);<br>        glPointSize(DEFAULT_LINE_WIDTH);<br>        bezier(ctrlPoints, nBezCurvePoints);<br>    }<br>    void UpdateCurve() {<br>        &#x2F;&#x2F; Check if there are enough control points to form a Bezier curve<br>        &#x2F;<em>if (currentCtrlPoints &lt; DEFAULT_BEZIER_CONTROL_POINTS_NUM) {<br>            printf(“Insufficient control points for Bezier curve.\n”);<br>            return;<br>        }</em>&#x2F;</p><pre><code class="hljs">    // Update the positions of the control points    for (int i = 0; i &lt; currentCtrlPoints; ++i) &#123;        ctrlPoints[i]-&gt;SetPosition(ctrlPoints[i]-&gt;transform.x,            ctrlPoints[i]-&gt;transform.y,            ctrlPoints[i]-&gt;transform.z);    &#125;    // Redraw the Bezier curve    Draw(GL_RENDER);&#125;struct wcPt3D &#123;    GLfloat x, y, z;&#125;;void plotPoint(wcPt3D bezCurvePt) &#123;    glBegin(GL_POINTS);    glVertex2f(bezCurvePt.x, bezCurvePt.y);    glEnd();&#125;void binomialCoeffs(GLint n, GLint* C) &#123;    GLint k, j;    for (k = 0; k &lt;= n; k++)    &#123;        C[k] = 1;        for (j = n; j &gt;= k + 1; j--)            C[k] *= j;        for (j = n - k; j &gt;= 2; j--)            C[k] /= j;    &#125;&#125;void computeBezPt(GLfloat u, wcPt3D* bezPt, GLint nCtrlPts,    wcPt3D* ctrlPts, GLint* C) &#123;    GLint k, n = nCtrlPts - 1;    GLfloat bezBlendFcn;    bezPt-&gt;x = bezPt-&gt;y = 0.0;    for (k = 0; k &lt; nCtrlPts; k++) &#123;        bezBlendFcn = C[k] * pow(1 - u, n - k) * pow(u, k);        bezPt-&gt;x += ctrlPts[k].x * bezBlendFcn;        bezPt-&gt;y += ctrlPts[k].y * bezBlendFcn;        //bezPt-&gt;z += ctrlPts[k].z * bezBlendFcn;    &#125;&#125;void drawBezier(wcPt3D* ctrlPts, GLint nCtrlPts, GLint    nBezCurvePts) &#123;    wcPt3D bezCurvePt;    GLfloat u;    GLint* C, k;    C = new GLint[nCtrlPts];    binomialCoeffs(nCtrlPts - 1, C);    for (k = 0; k &lt;= nBezCurvePts; k++)    &#123;        u = GLfloat(k) / GLfloat(nBezCurvePts);        computeBezPt(u, &amp;bezCurvePt, nCtrlPts, ctrlPts, C);        plotPoint(bezCurvePt);        //printf(&quot;%d/t&quot;, k);    &#125;    delete[] C;&#125;void bezier(GLPoint* ctrlPts[], GLint nBezCurvePts) &#123;    wcPt3D innerCtrlPts[MAX_BEZIER_CONTROL_POINTS_NUM];    for (int i = 0; i &lt; count; ++i)    &#123;        innerCtrlPts[i].x = (GLfloat)ctrlPts[i]-&gt;transform.x;        innerCtrlPts[i].y = (GLfloat)ctrlPts[i]-&gt;transform.y;        innerCtrlPts[i].z = (GLfloat)ctrlPts[i]-&gt;transform.z;    &#125;    drawBezier(innerCtrlPts, count, nBezCurvePts);    // 绘制控制点连线     if (ctrlPts[0] &amp;&amp; ctrlPts[0]-&gt;visible == false) return;    glColor3f(0.0, 1.0, 0.0);    glLineWidth(2.0);    glBegin(GL_LINE_STRIP);    for (int i = 0; i &lt; count; ++i)    &#123;        glVertex3d(ctrlPts[i]-&gt;transform.x,            ctrlPts[i]-&gt;transform.y, ctrlPts[i]-&gt;transform.z);    &#125;    glEnd();    glColor3f(1.0, 0.0, 0.0);    for (int i = 0; i &lt; count; ++i)    &#123;        ctrlPoints[i]-&gt;Draw();    &#125;&#125;</code></pre><p>};<br>“<br>.cpp文件：<br>“<br>#include”GLObject.h”<br>#include&lt;stdio.h&gt;<br>#include&lt;math.h&gt;<br>#include&lt;GL&#x2F;glut.h&gt;<br>#include&lt;GL&#x2F;glu.h&gt;<br>#include&lt;GL&#x2F;gl.h&gt;<br>GLWorld MyWorld;<br>GLBezierCtrlPts MyBezier[MAX_BEZIER_LINE_NUM];<br>GLState MyState &#x3D; MoveObject;<br>GLint LineNum &#x3D; 0;<br>&#x2F;* Set initial size of the display window. <em>&#x2F;<br>GLsizei winWidth &#x3D; 900, winHeight &#x3D; 600;<br> &#x2F;</em> Set size of world-coordinate clipping window. *&#x2F;<br> GLfloat xwcMin &#x3D; -450.0, xwcMax &#x3D; 450.0;<br> GLfloat ywcMin &#x3D; -300.0, ywcMax &#x3D; 300.0;</p><p> struct menuEntryStruct {<br>    const char* label;<br>     char key;</p><p> };</p><pre><code class="hljs">  static menuEntryStruct mainMenu[] = &#123; &quot;Reset&quot;, &#39;0&#39;,&quot;Create Bezier/Finish Bezier&quot;, &#39;1&#39;, &quot;Quit&quot;, 27,      //ESC 键（ASCII: 27）  &#125;;</code></pre><p> int mainMenuEntries &#x3D; sizeof(mainMenu) &#x2F; sizeof(menuEntryStruct);</p><pre><code class="hljs"> bool globalControlPointsVisible = true; void userEventAction(int key) &#123; switch (key) &#123; case &#39;0&#39;:     MyWorld.Empty();     MyWorld.pickedObjectId = -1;     MyState = MoveObject;     break; case &#39;1&#39;: // bezier      if (MyState == MoveObject)         &#123;         MyState = MakePoint;         ++LineNum;          &#125;      else if (MyState == MakePoint)         &#123;          MyState = MoveObject;                     &#125; break; case 27: // ESC 键（ASCII: 27）退出     MyWorld.Empty();      exit(0);      break; default:     break;     &#125;  glutPostRedisplay(); // 重绘</code></pre><p> }<br>     void keyboard(unsigned char key, int x, int y)<br>     {<br>         userEventAction(key);<br>     }<br>     void selectMain(int choice) &#x2F;&#x2F; 序号-&gt;key 映射<br>     {<br>         userEventAction(mainMenu[choice].key); &#x2F;&#x2F; 调用通用动作解释函数<br>     }<br>     void displayFcn(void)<br>          {<br>          glClear(GL_COLOR_BUFFER_BIT); &#x2F;&#x2F; Clear display window.<br>          for (int i &#x3D; 1; i &lt;&#x3D; LineNum;i++)MyBezier[i].Draw();<br>         glFlush();<br>         }</p><pre><code class="hljs"> void unProject(GLdouble winx, GLdouble winy, GLdouble winz, GLdouble* objx, GLdouble* objy, GLdouble*objz)     &#123;      // 从窗口到世界坐标系          GLint viewport[4];     GLdouble modelview[16];      GLdouble projection[16];     glGetDoublev(GL_MODELVIEW_MATRIX, modelview);      glGetDoublev(GL_PROJECTION_MATRIX, projection);      glGetIntegerv(GL_VIEWPORT, viewport);      gluUnProject(winx, winy, winz, modelview, projection, viewport         , objx, objy, objz);      &#125;       void mouseButton(int button, int state, int x, int y)      &#123;      switch (button) &#123;      case GLUT_LEFT_BUTTON:         break;      default:         return;             &#125;     switch (state) &#123;     case GLUT_DOWN:         if (MyState == MoveObject)              &#123;              MyWorld.PickObject(x, y);              printf(&quot;MyWorld.pickedObjectId: %d\n&quot;,MyWorld.pickedObjectId);             &#125;     else if (MyState == MakePoint)             &#123;            if  (GLPoint* ptr = MyWorld.objects[MyWorld.pickedObjectId])                 &#123;                // 从窗口到世界坐标系                     GLdouble winx = (GLdouble)x;                 GLdouble winy = (GLdouble)winHeight - (GLdouble)                     y;                GLdouble winz = 0;                  GLdouble objx = 0;                 GLdouble objy = 0;                 GLdouble objz = 0;                  unProject(winx, winy, winz, &amp;objx, &amp;objy, &amp;objz);                 MyBezier[LineNum].parentWorld = &amp;MyWorld;                  MyBezier[LineNum].MakePoint(objx, objy, objz);                                     &#125;             &#125;         break;     case GLUT_UP:          glutPostRedisplay();         break;             &#125;     &#125;      void mouseMotion(int x, int y)         &#123;          if (MyWorld.pickedObjectId == -1) return;          if (!MyWorld.objects[MyWorld.pickedObjectId]-&gt;movable) return;                      GLPoint * ptr = MyWorld.objects[MyWorld.pickedObjectId];                      // 从窗口到世界坐标系              GLdouble winx = (GLdouble)x;           GLdouble winy = (GLdouble)winHeight - (GLdouble)y;          GLdouble winz = 0;           GLdouble objx = 0;          GLdouble objy = 0;          GLdouble objz = 0;           unProject(winx, winy, winz, &amp;objx, &amp;objy, &amp;objz);                        ptr-&gt;SetPosition(objx, objy, objz);                        glutPostRedisplay();          &#125;      void init(void)      &#123;          glClearColor(1.0, 1.0, 1.0, 0.0); // Set display-window color to white.          glMatrixMode(GL_PROJECTION);          glutCreateMenu(selectMain);          glutCreateMenu(selectMain); // 使用 selectMain 作为菜单调用函数          for (int i = 0; i &lt; mainMenuEntries; i++) &#123;              glutAddMenuEntry(mainMenu[i].label, i);          &#125;          glutAttachMenu(GLUT_RIGHT_BUTTON); // 菜单绑定右键          gluOrtho2D(xwcMin, xwcMax, ywcMin, ywcMax);      &#125;      void display(void)      &#123;          glClear(GL_COLOR_BUFFER_BIT); // Clear display window.          for (int i = 1; i &lt;= LineNum; i++)              MyBezier[i].Draw();          glFlush();      &#125;      void reshape(int newWidth, int newHeight)      &#123;          glViewport(0, 0, newWidth, newHeight);          winWidth = newWidth;          winHeight = newHeight;      &#125;      void winReshapeFcn(int newWidth, int newHeight)      &#123;          if (newWidth &gt; newHeight)              glViewport((newWidth - newHeight) / 2, 0, newHeight, newHeight);          else              glViewport(0, (newHeight - newWidth) / 2, newWidth, newWidth);          glMatrixMode(GL_PROJECTION);          glLoadIdentity();          gluOrtho2D(xwcMin, xwcMax, ywcMin, ywcMax);      &#125;      void menuFcn(int value)      &#123;          userEventAction(mainMenu[value].key);      &#125;      void createMenu()      &#123;          int menu = glutCreateMenu(menuFcn);          for (int i = 0; i &lt; mainMenuEntries; i++)          &#123;              glutAddMenuEntry(mainMenu[i].label, i);          &#125;          glutAttachMenu(GLUT_RIGHT_BUTTON);      &#125;      int main(int argc, char** argv)      &#123;          glutInit(&amp;argc, argv);          glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);          glutInitWindowPosition(100, 100);          glutInitWindowSize(winWidth, winHeight);          glutCreateWindow(&quot;My World&quot;);          init();          glutDisplayFunc(display);          glutReshapeFunc(winReshapeFcn);          glutMouseFunc(mouseButton);          glutMotionFunc(mouseMotion);          glutKeyboardFunc(keyboard);          glutMainLoop();          return 0;      &#125;</code></pre><p>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;*<br>&#x2F;&#x2F;* ###############OpenGL绘制贝塞尔曲线(Bézier_curve)###############<br>&#x2F;&#x2F;*<br>&#x2F;&#x2F;* 说明：<br>&#x2F;&#x2F;* 主要参考<a href="https://blog.csdn.net/qq_41856733/article/details/85309521">https://blog.csdn.net/qq_41856733/article/details/85309521</a><br>&#x2F;&#x2F;* GL相关函数可参考<a href="https://docs.microsoft.com/zh-cn/windows/win32/opengl/gllinestipple">https://docs.microsoft.com/zh-cn/windows/win32/opengl/gllinestipple</a><br>&#x2F;&#x2F;* vs2019配置OpenGL可参考<a href="https://blog.csdn.net/weixin_41894030/article/details/100381865">https://blog.csdn.net/weixin_41894030/article/details/100381865</a><br>&#x2F;&#x2F;* 如有侵权行为或其他不当之处欢迎联系作者：<a href="mailto:&#50;&#56;&#x30;&#51;&#49;&#54;&#x38;&#54;&#52;&#x39;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#50;&#56;&#x30;&#51;&#49;&#54;&#x38;&#54;&#52;&#x39;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a><br>&#x2F;&#x2F;<em>&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;#include &lt;windows.h&gt;<br>&#x2F;&#x2F;#include &lt;GL&#x2F;glut.h&gt;<br>&#x2F;&#x2F;#include &lt;math.h&gt;<br>&#x2F;&#x2F;#include &lt;stdio.h&gt;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;#define    MAXPOINTS    20<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;int</em> C;&#x2F;&#x2F;二项式系数数组指针<br>&#x2F;&#x2F;int control_points_n &#x3D; 0;&#x2F;&#x2F;控制点数量<br>&#x2F;&#x2F;int specific_p;&#x2F;&#x2F;特定点标志<br>&#x2F;&#x2F;int click_state &#x3D; 0;&#x2F;&#x2F;0为新增控制点，1为移动控制点，2为已到底控制点最大值<br>&#x2F;&#x2F;int screen_width, screen_height;&#x2F;&#x2F;屏幕宽度，长度<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;struct point<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int x;<br>&#x2F;&#x2F;    int y;<br>&#x2F;&#x2F;};<br>&#x2F;&#x2F;point* P;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;函数声明<br>&#x2F;&#x2F;void reshape(int w, int h);&#x2F;&#x2F;自适应屏幕窗口大小的改变<br>&#x2F;&#x2F;void keyboard(unsigned char button, int x, int y);&#x2F;&#x2F;控制按键函数<br>&#x2F;&#x2F;void mouse_click(int button, int state, int x, int y);&#x2F;&#x2F;处理鼠标click事件函数<br>&#x2F;&#x2F;void mouse_motion(int x, int y);&#x2F;&#x2F;鼠标在窗口中按下并移动时调用此函数<br>&#x2F;&#x2F;void display(void);&#x2F;&#x2F;显示函数,需要显示时调用此函数<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;定位坐标函数<br>&#x2F;&#x2F;void gotoxy(int x, int y) {<br>&#x2F;&#x2F;    COORD coord;<br>&#x2F;&#x2F;    coord.X &#x3D; x;<br>&#x2F;&#x2F;    coord.Y &#x3D; y;<br>&#x2F;&#x2F;    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;int main(int argc, char** argv)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    P &#x3D; new point[MAXPOINTS];&#x2F;&#x2F;控制点数组指针<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    printf(“按下&quot;ESC&quot;键退出。按下&quot;R&quot;键重新绘制\r\n”);<br>&#x2F;&#x2F;    printf(“最多添加20个点”);<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    glutInit(&amp;argc, argv);&#x2F;&#x2F;gult初始化<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;<em>在创建窗口的时候，指定其显示模式的类型。GLUT_DOUBLE代表双缓冲<br>&#x2F;&#x2F;    详见<a href="https://blog.csdn.net/yangyong0717/article/details/78003913">https://blog.csdn.net/yangyong0717/article/details/78003913</a></em>&#x2F;<br>&#x2F;&#x2F;    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);<br>&#x2F;&#x2F;    glutInitWindowPosition(100, 100);&#x2F;&#x2F;初始化窗口距离屏幕左边和上面的像素数<br>&#x2F;&#x2F;    glutInitWindowSize(500, 500);&#x2F;&#x2F;初始化窗口宽度和高度<br>&#x2F;&#x2F;    glutCreateWindow(“Bézier curve”);&#x2F;&#x2F;创建窗口，”Bézier curve”为窗口名字<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;清除颜色缓冲区,防止缓冲区中原有的颜色信息影响本次绘图<br>&#x2F;&#x2F;    &#x2F;&#x2F;详见<a href="https://blog.csdn.net/jennifer111111/article/details/51649153">https://blog.csdn.net/jennifer111111/article/details/51649153</a><br>&#x2F;&#x2F;    glClearColor(1.0, 1.0, 1.0, 1.0);<br>&#x2F;&#x2F;    glEnable(GL_LINE_STIPPLE);&#x2F;&#x2F;启用直线点画功能<br>&#x2F;&#x2F;    glutReshapeFunc(reshape);&#x2F;&#x2F;若屏幕窗口大小改变则调用reshape函数<br>&#x2F;&#x2F;    glutKeyboardFunc(keyboard);&#x2F;&#x2F;处理普通按键消息。详见<a href="https://blog.csdn.net/xie_zi/article/details/1911891">https://blog.csdn.net/xie_zi/article/details/1911891</a><br>&#x2F;&#x2F;    glutMouseFunc(mouse_click);&#x2F;&#x2F;处理鼠标click事件<br>&#x2F;&#x2F;    glutMotionFunc(mouse_motion);&#x2F;&#x2F;当鼠标在窗口中按下并移动时调用glutMotionFunc注册的回调函数<br>&#x2F;&#x2F;    glutDisplayFunc(display);&#x2F;&#x2F;当窗口内容被绘制时调用display函数<br>&#x2F;&#x2F;    glutMainLoop();&#x2F;&#x2F;进入gult死循环<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    delete[] P;<br>&#x2F;&#x2F;    return 1;<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;画正方形，用来标记点<br>&#x2F;&#x2F;void Draw_Square(int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    glColor3f(0, 1, 0);&#x2F;&#x2F;设置颜色，三个参数分别代表red, green, blue<br>&#x2F;&#x2F;    glBegin(GL_POLYGON);&#x2F;&#x2F;绘制了一个凸多边形。顶点1到n定义了这个多边形。<br>&#x2F;&#x2F;    glVertex2f(x + 2, y + 2);<br>&#x2F;&#x2F;    glVertex2f(x - 2, y + 2);<br>&#x2F;&#x2F;    glVertex2f(x - 2, y - 2);<br>&#x2F;&#x2F;    glVertex2f(x + 2, y - 2);<br>&#x2F;&#x2F;    glEnd();<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;<em>计算二项式系数<br>&#x2F;&#x2F;</em> n为次数，C为存放二项式系数的数组<br>&#x2F;&#x2F;* 利用了C(n-k)(n)&#x3D;C(k)(n)<br>&#x2F;&#x2F;* 即C[k] &#x3D; C(k)(n),k在右上角，n在左下角（不知道怎么打那个符号。。）*&#x2F;<br>&#x2F;&#x2F;void Culculate_Binomial_Coefficient(int n, int* C)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int k, j;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    for (k &#x3D; 0;k &lt;&#x3D; n;k++)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        C[k] &#x3D; 1;<br>&#x2F;&#x2F;        for (j &#x3D; n;j &gt;&#x3D; k + 1;j–)&#x2F;&#x2F;1<em>n</em>(n-1)<em>(n-2)</em>…<em>(k+2)</em>(k+1)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            C[k] <em>&#x3D; j;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        for (j &#x3D; n - k;j &gt;&#x3D; 2;j–)&#x2F;&#x2F;上式 &#x2F; ( (n-k)</em>(n-k-1)<em>…<em>3</em>2</em>1 )<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            C[k] &#x2F;&#x3D; j;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;画贝塞尔曲线<br>&#x2F;&#x2F;&#x2F;&#x2F;n为维度（即控制点数减1），p为控制点数组，m为密度<br>&#x2F;&#x2F;void Draw_Bézier_curve(int n, point* p, int m)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int i, j;<br>&#x2F;&#x2F;    float t;<br>&#x2F;&#x2F;    int C[MAXPOINTS - 1];&#x2F;&#x2F;二项式系数数组。这样定义有些浪费空间，但不知道更好的办法<br>&#x2F;&#x2F;    &#x2F;&#x2F;算出来的曲线轨迹点x坐标。用float型相比int型曲线会更平滑<br>&#x2F;&#x2F;    float Bézier_curve_pointx;<br>&#x2F;&#x2F;    float Bézier_curve_pointy;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    Culculate_Binomial_Coefficient(n, C);<br>&#x2F;&#x2F;    glLineStipple(1, 0xffff);&#x2F;&#x2F;设置为实线<br>&#x2F;&#x2F;    glBegin(GL_LINE_STRIP);<br>&#x2F;&#x2F;    &#x2F;&#x2F;这里实际上是画了m条短直线来接近贝塞尔曲线<br>&#x2F;&#x2F;    for (i &#x3D; 0;i &lt;&#x3D; m;i++)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        t &#x3D; (float)i &#x2F; (float)m;<br>&#x2F;&#x2F;        Bézier_curve_pointx &#x3D; 0;<br>&#x2F;&#x2F;        Bézier_curve_pointy &#x3D; 0;<br>&#x2F;&#x2F;        for (j &#x3D; 0;j &lt; control_points_n;j++)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            Bézier_curve_pointx +&#x3D; C[j] * pow(1 - t, control_points_n - j - 1) * pow(t, j) * p[j].x;<br>&#x2F;&#x2F;            Bézier_curve_pointy +&#x3D; C[j] * pow(1 - t, control_points_n - j - 1) * pow(t, j) * p[j].y;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        glVertex2f(Bézier_curve_pointx, Bézier_curve_pointy);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    glEnd();<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;自适应屏幕窗口大小的改变<br>&#x2F;&#x2F;&#x2F;&#x2F;关于reshape函数可以参考<a href="https://blog.csdn.net/qq_41856733/article/details/85309521">https://blog.csdn.net/qq_41856733/article/details/85309521</a><br>&#x2F;&#x2F;void reshape(int w, int h)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    screen_width &#x3D; w;<br>&#x2F;&#x2F;    screen_height &#x3D; h;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    glViewport(0, 0, w, h);<br>&#x2F;&#x2F;    glMatrixMode(GL_PROJECTION);<br>&#x2F;&#x2F;    glLoadIdentity();<br>&#x2F;&#x2F;    gluOrtho2D(0.0, w, 0.0, h);<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;控制按键函数<br>&#x2F;&#x2F;void keyboard(unsigned char button, int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    switch (button)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;    case 82:&#x2F;&#x2F;“R”<br>&#x2F;&#x2F;    case 114:&#x2F;&#x2F;“r”<br>&#x2F;&#x2F;        &#x2F;&#x2F;重新绘图<br>&#x2F;&#x2F;        &#x2F;&#x2F;清空之前显示的坐标<br>&#x2F;&#x2F;        gotoxy(0, 3);<br>&#x2F;&#x2F;        for (int i &#x3D; 0;i &lt; control_points_n;i++)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            printf(“                   \r\n”);<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;        specific_p &#x3D; control_points_n &#x3D; 0;<br>&#x2F;&#x2F;        click_state &#x3D; 0;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;        &#x2F;*glutPostRedisplay函数用来标记当前窗口需要重新绘制。通过glutMainLoop<br>&#x2F;&#x2F;        * 下一次循环时，窗口显示将被回调以重新显示窗口的正常面板*&#x2F;<br>&#x2F;&#x2F;        glutPostRedisplay();<br>&#x2F;&#x2F;        break;<br>&#x2F;&#x2F;    case 27:&#x2F;&#x2F;“ESC”<br>&#x2F;&#x2F;        exit(0);&#x2F;&#x2F;退出glut循环<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;*<br>&#x2F;&#x2F;* 处理鼠标click事件函数<br>&#x2F;&#x2F;* button表明哪个鼠标键被按下或松开,第二个参数表明函数被调用发生时鼠标的<br>&#x2F;&#x2F;* 状态（按下或松开），x,y表示鼠标在当前窗口的坐标（以左上角为原点）<br>&#x2F;&#x2F;*&#x2F;<br>&#x2F;&#x2F;void mouse_click(int button, int state, int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int i;<br>&#x2F;&#x2F;    int distance;&#x2F;&#x2F;鼠标点击处于任意一点距离<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;如果鼠标左键按下<br>&#x2F;&#x2F;    if (button &#x3D;&#x3D; GLUT_LEFT_BUTTON)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        &#x2F;&#x2F;不是移动状态时计算距离<br>&#x2F;&#x2F;        if (state &#x3D;&#x3D; GLUT_DOWN &amp;&amp; click_state !&#x3D; 1)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            for (i &#x3D; 0;i &lt; control_points_n;i++)<br>&#x2F;&#x2F;            {<br>&#x2F;&#x2F;                &#x2F;&#x2F;按控制点依次计算距离<br>&#x2F;&#x2F;                distance &#x3D; (x - P[i].x) * (x - P[i].x) +<br>&#x2F;&#x2F;                    (screen_height - y - P[i].y) * (screen_height - y - P[i].y);<br>&#x2F;&#x2F;                if (distance &lt; 15)&#x2F;&#x2F;如果距离小于特定值<br>&#x2F;&#x2F;                {<br>&#x2F;&#x2F;                    click_state &#x3D; 1;&#x2F;&#x2F;进入状态1，即移动点<br>&#x2F;&#x2F;                    specific_p &#x3D; i;<br>&#x2F;&#x2F;                    break;&#x2F;&#x2F;跳出循环<br>&#x2F;&#x2F;                }<br>&#x2F;&#x2F;            }<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;        if (state &#x3D;&#x3D; GLUT_DOWN &amp;&amp; click_state &#x3D;&#x3D; 0)&#x2F;&#x2F;新增点<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            if (control_points_n &lt; MAXPOINTS)<br>&#x2F;&#x2F;            {<br>&#x2F;&#x2F;                P[control_points_n].x &#x3D; x;<br>&#x2F;&#x2F;                P[control_points_n].y &#x3D; screen_height - y;<br>&#x2F;&#x2F;                specific_p &#x3D; control_points_n;<br>&#x2F;&#x2F;                control_points_n++;<br>&#x2F;&#x2F;                glutPostRedisplay();<br>&#x2F;&#x2F;            }<br>&#x2F;&#x2F;            else click_state &#x3D; 2;&#x2F;&#x2F;进入状态2，无法新增控制点<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        else if (state &#x3D;&#x3D; GLUT_DOWN &amp;&amp; click_state &#x3D;&#x3D; 1)&#x2F;&#x2F;移动点<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            P[specific_p].x &#x3D; x;<br>&#x2F;&#x2F;            P[specific_p].y &#x3D; screen_height - y;<br>&#x2F;&#x2F;            glutPostRedisplay();<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        else if (state &#x3D;&#x3D; GLUT_UP)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            &#x2F;&#x2F;判断控制点是否已达上限<br>&#x2F;&#x2F;            click_state &#x3D; control_points_n &lt; MAXPOINTS ? 0 : 2;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;鼠标在窗口中按下并移动时调用此函数<br>&#x2F;&#x2F;void mouse_motion(int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    if (click_state &#x3D;&#x3D; 1)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        P[specific_p].x &#x3D; x;<br>&#x2F;&#x2F;        P[specific_p].y &#x3D; screen_height - y;<br>&#x2F;&#x2F;        glutPostRedisplay();<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;显示函数,需要显示时调用此函数<br>&#x2F;&#x2F;void display(void)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int i;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    glClear(GL_COLOR_BUFFER_BIT);&#x2F;&#x2F;清缓存。GL_COLOR_BUFFER_BIT代表当前可写的颜色缓冲<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    for (i &#x3D; 0;i &lt; control_points_n;i++)&#x2F;&#x2F;画控制点<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        Draw_Square(P[i].x, P[i].y);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    &#x2F;&#x2F;显示控制点坐标<br>&#x2F;&#x2F;    gotoxy(0, specific_p + 3);<br>&#x2F;&#x2F;    printf(“P%d:(%d, %d)  “, specific_p, P[specific_p].x, P[specific_p].y);<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;0x0f0f即0000 1111 0000 1111，即黑白等长的虚线<br>&#x2F;&#x2F;    &#x2F;&#x2F;glLineStipple函数详见<a href="https://blog.csdn.net/oktears/article/details/42262187">https://blog.csdn.net/oktears/article/details/42262187</a><br>&#x2F;&#x2F;    glLineStipple(1, 0x0f0f);<br>&#x2F;&#x2F;    glBegin(GL_LINE_STRIP);&#x2F;&#x2F;启用直线点画功能<br>&#x2F;&#x2F;    glColor3f(1, 0, 0);&#x2F;&#x2F;设置颜色，三个参数分别代表red, green, blue<br>&#x2F;&#x2F;    for (i &#x3D; 0;i &lt; control_points_n;i++)&#x2F;&#x2F;画虚线<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        glVertex2f(P[i].x, P[i].y);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    glEnd();<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    if (control_points_n &gt; 1)&#x2F;&#x2F;有大于1个控制点就画出贝塞尔曲线<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        Draw_Bézier_curve(control_points_n - 1, P, 200);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;函数详见<a href="https://blog.csdn.net/u012442207/article/details/45223261">https://blog.csdn.net/u012442207/article/details/45223261</a><br>&#x2F;&#x2F;    glutSwapBuffers();&#x2F;&#x2F;交换两个缓冲区指针<br>&#x2F;&#x2F;}<br>“</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/2023/11/16/hexo-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%BF%83%E5%BE%97/"/>
    <url>/2023/11/16/hexo-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/15/hello-world/"/>
    <url>/2023/11/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>眼中的星星的first Blog</title>
    <link href="/2023/11/15/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/11/15/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2023/11/15/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class=""><p>第一次用这种方式来写博客，感觉还不错诶<br>希望会有好的文章产出，也给自己的大学生活留下足迹<br>其实我自己还是很喜欢敲电脑的，可以学到很多东西<br>你是第一个来访问我的博客的哦，谢谢你！！！</p><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
