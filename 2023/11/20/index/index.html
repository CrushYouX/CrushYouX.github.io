

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CrushYouX">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机图形学绘制贝塞尔曲线真的是难绷，那个用鼠标拖动始终完成不了，先立个flag在这里，我两天之内一定要解决这个问题，先把现在的代码存在这里：“头文件”“#pragma once#define MAX_OBJECTS 10000#define DEFAULT_POINT_SIZE 10#define DEFAULT_LINE_WIDTH 5#define DEFAULT_BEZIER_CONTRO">
<meta property="og:type" content="article">
<meta property="og:title" content="Opengl 的贝塞尔曲线绘制">
<meta property="og:url" content="http://example.com/2023/11/20/index/index.html">
<meta property="og:site_name" content="眼里的星星的个人博客">
<meta property="og:description" content="计算机图形学绘制贝塞尔曲线真的是难绷，那个用鼠标拖动始终完成不了，先立个flag在这里，我两天之内一定要解决这个问题，先把现在的代码存在这里：“头文件”“#pragma once#define MAX_OBJECTS 10000#define DEFAULT_POINT_SIZE 10#define DEFAULT_LINE_WIDTH 5#define DEFAULT_BEZIER_CONTRO">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-20T13:41:33.000Z">
<meta property="article:modified_time" content="2023-11-20T13:45:29.218Z">
<meta property="article:author" content="CrushYouX">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Opengl 的贝塞尔曲线绘制 - 眼里的星星的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"WAQyDRcuzrK2cZjVhUWaqfpC-gzGzoHsz","app_key":"Lf7r7JrEwvMcsBEeb3KngwSY","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>眼中的星星</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Opengl 的贝塞尔曲线绘制"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-20 21:41" pubdate>
          2023年11月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          182 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span>次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Opengl 的贝塞尔曲线绘制</h1>
            
            
              <div class="markdown-body">
                
                <p>计算机图形学绘制贝塞尔曲线真的是难绷，那个用鼠标拖动始终完成不了，先立个flag在这里，我两天之内一定要解决这个问题，先把现在的代码存在这里：<br>“头文件”<br>“#pragma once<br>#define MAX_OBJECTS 10000<br>#define DEFAULT_POINT_SIZE 10<br>#define DEFAULT_LINE_WIDTH 5<br>#define DEFAULT_BEZIER_CONTROL_POINTS_NUM 4<br>#define MAX_BEZIER_CONTROL_POINTS_NUM 13<br>#define DEFAULT_PICK_BUFFER_SIZE 32<br>#define DEFAULT_PICK_WINDOW_SIZE 10<br>#define MAX_BEZIER_LINE_NUM 5<br>#define PI 3.14159265358979323846 &#x2F;&#x2F; pi<br>#include&lt;stdio.h&gt;<br>#include&lt;math.h&gt;<br>#include&lt;GL&#x2F;glut.h&gt;<br>#include&lt;GL&#x2F;glu.h&gt;<br>#include&lt;GL&#x2F;gl.h&gt;<br>struct GLTransform;<br>struct GLWorld;<br>enum GLState {<br>    MoveObject,<br>    MakePoint<br>};</p>
<p>struct GLColor<br>{<br>    GLfloat r &#x3D; 0, g &#x3D; 0, b &#x3D; 0;<br>};</p>
<p>struct GLTransform<br>{<br>    &#x2F;&#x2F; 世界坐标，轴旋转，轴缩放<br>    GLdouble x &#x3D; 0, y &#x3D; 0, z &#x3D; 0;<br>    GLdouble rx &#x3D; 0, ry &#x3D; 0, rz &#x3D; 0;<br>    GLdouble sx &#x3D; 1, sy &#x3D; 1, sz &#x3D; 1;<br>};<br>struct GLPoint {<br>    GLint id &#x3D; 0;<br>    GLColor color;<br>    GLTransform transform;<br>    bool movable &#x3D;true;<br>    bool visible &#x3D; true;</p>
<pre><code class="hljs">GLWorld* parentWorld;
void SetPosition(GLdouble x, GLdouble y, GLdouble z) &#123;
    transform.x = x;
    transform.y = y;
    transform.z = z;

&#125;
void Draw(GLenum RenderMode = GL_RENDER)
&#123;
    // 需要在绘制前调用 SetPostion，否则绘制在原点
    if (!visible) return;
    if (RenderMode == GL_SELECT) glLoadName((GLuint)id);
    glColor3f(1, 0, 0);
    glPointSize(DEFAULT_POINT_SIZE);
    glBegin(GL_POINTS);
    glVertex3d(transform.x, transform.y, transform.z);
    glEnd();
&#125;
</code></pre>
<p>};<br>struct GLWorld<br>{<br>    GLPoint* objects[MAX_OBJECTS];<br>    GLint count &#x3D; 0;</p>
<pre><code class="hljs">GLPoint* CreatePt(GLdouble x, GLdouble y, GLdouble z) &#123;
    if (count &lt; MAX_OBJECTS)
    &#123;
        GLPoint* ret = (GLPoint*)malloc(sizeof(GLPoint));
        objects[count] = ret;
        //objects[count]-&gt;parentWorld = this;
        //objects[count]-&gt;id = count;
        objects[count]-&gt;SetPosition(x, y, z);
        ++count;
        return ret;
    &#125;
    else return nullptr;
&#125;

void DeleteObject(GLint id)//根据 id 删除一个对象
&#123;
    for (int i = 0; i &lt; count; ++i) &#123;
        if (objects[i]-&gt;id == id) &#123;
            free(objects[i]);
            objects[i] = nullptr;
            // 将删除的对象后面的对象向前移动
            for (int j = i; j &lt; count - 1; ++j) &#123;
                objects[j] = objects[j + 1];
            &#125;
            objects[count - 1] = nullptr;
            --count;
            break;
        &#125;
    &#125;
&#125;
void Empty()//清空所有对象
&#123;
    for (int i = 0; i &lt; count; ++i) &#123;
        free(objects[i]);
        //objects[i] = nullptr;
    &#125;
    count = 0;
 &#125;

void DrawObjects(GLenum RenderMode = GL_RENDER) &#123;
    for (int i = 0; i &lt; count; ++i)
    &#123;
        if (!objects[i]) return;
        objects[i]-&gt;Draw(RenderMode);
    &#125;


&#125;

GLint pickedObjectId = -1;
void PickObject(GLint xMouse, GLint yMouse) &#123;
    pickRects(GLUT_LEFT_BUTTON, GLUT_DOWN, xMouse, yMouse);
&#125;

//void pickRects(GLint button, GLint action, GLint xMouse, GLint yMouse);
//void processPicks(GLint nPicks, GLuint pickBuffer[]);
GLuint pickBuffer[DEFAULT_PICK_BUFFER_SIZE];
GLint nPicks, vpArray[4];
</code></pre>
<p> GLfloat xwcMin, xwcMax, ywcMin, ywcMax;<br>    void processPicks(GLint nPicks, GLuint pickBuffer[])</p>
<pre><code class="hljs">&#123;
    // 储存获取到的最后一个 ID，即认为后绘制的图像在先绘制的图形之上 
    if (nPicks == 0) pickedObjectId = -1;
    else
    &#123;
        // 因为只使用一个栈顶元素，所以可以由公式计算得出最后一个图形 ID
        int chunkId = 4 * (nPicks - 1);
        pickedObjectId = pickBuffer[chunkId + 3];
    &#125;
    return;
&#125;
void pickRects(GLint button, GLint action, GLint xMouse, GLint yMouse)
&#123;
    GLuint pickBuffer[DEFAULT_PICK_BUFFER_SIZE];
    GLint vpArray[4];
    if (button != GLUT_LEFT_BUTTON || action != GLUT_DOWN)
        return;

    glSelectBuffer(DEFAULT_PICK_BUFFER_SIZE, pickBuffer); //  Designate pick buffer.
    glRenderMode(GL_SELECT); // Activate picking operations.
    glInitNames(); // Initialize the object￾ID stack. 

    // 只使用一个栈顶元素，后续为图形命名使用 glLoadName(id) 替换栈顶
    glPushName(MAX_OBJECTS);

    /* Save current viewing matrix. */
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();

    /* Obtain the parameters for the current viewport. Set up
    75. * a 5 x 5 pick window, and invert the input yMouse value
    76. * using the height of the viewport, which is the fourth
    77. * element of vpArray.
    78. */
    glGetIntegerv(GL_VIEWPORT, vpArray);
    gluPickMatrix(GLdouble(xMouse), GLdouble(yMouse), DEFAULT_PICK_WINDOW_SIZE, DEFAULT_PICK_WINDOW_SIZE, vpArray);
    gluOrtho2D(xwcMin, xwcMax, ywcMin, ywcMax);
    //rects (GL_SELECT); // Process the rectangles in selection mode.
    this-&gt;DrawObjects(GL_SELECT);

    /* Restore original viewing matrix. */
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();

    glFlush();

    /* Determine the number of picked objects and return to the
   94. * normal rendering mode.
   95. */
    nPicks =glRenderMode(GL_RENDER);
    processPicks(nPicks, pickBuffer); // Process picked  objects.
    glutPostRedisplay();
&#125;
</code></pre>
<p>};</p>
<p>struct GLBezierCtrlPts<br>{<br>    GLWorld* parentWorld;<br>    GLPoint* ctrlPoints[MAX_BEZIER_CONTROL_POINTS_NUM];<br>    int count &#x3D; 0;<br>    GLint nBezCurvePoints &#x3D; 1000;<br>    int currentCtrlPoints &#x3D; 0;<br>    &#x2F;&#x2F; Usage:<br>     &#x2F;&#x2F;GLWorld::NewObject<GLBezier>()-&gt;MakePoint(x,y,z);<br>    &#x2F;**&#x2F;<br>    void MakePoint(GLdouble x, GLdouble y, GLdouble z) {<br>        if (count &gt;&#x3D; MAX_BEZIER_CONTROL_POINTS_NUM) return;<br>        ctrlPoints[count] &#x3D; parentWorld-&gt;CreatePt(x, y, z);<br>        ctrlPoints[count]-&gt;SetPosition(x, y, z);<br>        ctrlPoints[count]-&gt;movable &#x3D; true;<br>        count++;<br>        currentCtrlPoints++;  &#x2F;&#x2F; 每次新增控制点时递增<br>    }<br>    void Draw(GLenum RenderMode &#x3D; GL_RENDER) {<br>        &#x2F;&#x2F; 需要在绘制前初始化控制点<br>        if (count &#x3D;&#x3D; 0) return;<br>        for (int i &#x3D; 0; i &lt; count; ++i)<br>        {<br>            if (!ctrlPoints[i]) return;<br>        }<br>        &#x2F;&#x2F;if (RenderMode &#x3D;&#x3D; GL_SELECT) glLoadName((GLuint)id);<br>        glColor3f(0.0, 0.0, 0.0);<br>        glPointSize(DEFAULT_LINE_WIDTH);<br>        bezier(ctrlPoints, nBezCurvePoints);<br>    }<br>    void UpdateCurve() {<br>        &#x2F;&#x2F; Check if there are enough control points to form a Bezier curve<br>        &#x2F;<em>if (currentCtrlPoints &lt; DEFAULT_BEZIER_CONTROL_POINTS_NUM) {<br>            printf(“Insufficient control points for Bezier curve.\n”);<br>            return;<br>        }</em>&#x2F;</p>
<pre><code class="hljs">    // Update the positions of the control points
    for (int i = 0; i &lt; currentCtrlPoints; ++i) &#123;
        ctrlPoints[i]-&gt;SetPosition(ctrlPoints[i]-&gt;transform.x,
            ctrlPoints[i]-&gt;transform.y,
            ctrlPoints[i]-&gt;transform.z);
    &#125;

    // Redraw the Bezier curve
    Draw(GL_RENDER);
&#125;

struct wcPt3D &#123;

    GLfloat x, y, z;
&#125;;
void plotPoint(wcPt3D bezCurvePt) &#123;
    glBegin(GL_POINTS);
    glVertex2f(bezCurvePt.x, bezCurvePt.y);
    glEnd();

&#125;
void binomialCoeffs(GLint n, GLint* C) &#123;
    GLint k, j;
    for (k = 0; k &lt;= n; k++)

    &#123;
        C[k] = 1;
        for (j = n; j &gt;= k + 1; j--)
            C[k] *= j;
        for (j = n - k; j &gt;= 2; j--)
            C[k] /= j;
    &#125;
&#125;
void computeBezPt(GLfloat u, wcPt3D* bezPt, GLint nCtrlPts,
    wcPt3D* ctrlPts, GLint* C) &#123;
    GLint k, n = nCtrlPts - 1;
    GLfloat bezBlendFcn;
    bezPt-&gt;x = bezPt-&gt;y = 0.0;
    for (k = 0; k &lt; nCtrlPts; k++) &#123;
        bezBlendFcn = C[k] * pow(1 - u, n - k) * pow(u, k);
        bezPt-&gt;x += ctrlPts[k].x * bezBlendFcn;
        bezPt-&gt;y += ctrlPts[k].y * bezBlendFcn;
        //bezPt-&gt;z += ctrlPts[k].z * bezBlendFcn;

    &#125;

&#125;
void drawBezier(wcPt3D* ctrlPts, GLint nCtrlPts, GLint
    nBezCurvePts) &#123;
    wcPt3D bezCurvePt;
    GLfloat u;
    GLint* C, k;
    C = new GLint[nCtrlPts];
    binomialCoeffs(nCtrlPts - 1, C);
    for (k = 0; k &lt;= nBezCurvePts; k++)
    &#123;
        u = GLfloat(k) / GLfloat(nBezCurvePts);
        computeBezPt(u, &amp;bezCurvePt, nCtrlPts, ctrlPts, C);
        plotPoint(bezCurvePt);
        //printf(&quot;%d/t&quot;, k);
    &#125;
    delete[] C;

&#125;
void bezier(GLPoint* ctrlPts[], GLint nBezCurvePts) &#123;

    wcPt3D innerCtrlPts[MAX_BEZIER_CONTROL_POINTS_NUM];
    for (int i = 0; i &lt; count; ++i)
    &#123;
        innerCtrlPts[i].x = (GLfloat)ctrlPts[i]-&gt;transform.x;
        innerCtrlPts[i].y = (GLfloat)ctrlPts[i]-&gt;transform.y;
        innerCtrlPts[i].z = (GLfloat)ctrlPts[i]-&gt;transform.z;
    &#125;
    drawBezier(innerCtrlPts, count, nBezCurvePts);

    // 绘制控制点连线 
    if (ctrlPts[0] &amp;&amp; ctrlPts[0]-&gt;visible == false) return;
    glColor3f(0.0, 1.0, 0.0);
    glLineWidth(2.0);
    glBegin(GL_LINE_STRIP);
    for (int i = 0; i &lt; count; ++i)
    &#123;
        glVertex3d(ctrlPts[i]-&gt;transform.x,
            ctrlPts[i]-&gt;transform.y, ctrlPts[i]-&gt;transform.z);
    &#125;
    glEnd();
    glColor3f(1.0, 0.0, 0.0);

    for (int i = 0; i &lt; count; ++i)
    &#123;
        ctrlPoints[i]-&gt;Draw();
    &#125;

&#125;
</code></pre>
<p>};<br>“<br>.cpp文件：<br>“<br>#include”GLObject.h”<br>#include&lt;stdio.h&gt;<br>#include&lt;math.h&gt;<br>#include&lt;GL&#x2F;glut.h&gt;<br>#include&lt;GL&#x2F;glu.h&gt;<br>#include&lt;GL&#x2F;gl.h&gt;<br>GLWorld MyWorld;<br>GLBezierCtrlPts MyBezier[MAX_BEZIER_LINE_NUM];<br>GLState MyState &#x3D; MoveObject;<br>GLint LineNum &#x3D; 0;<br>&#x2F;* Set initial size of the display window. <em>&#x2F;<br>GLsizei winWidth &#x3D; 900, winHeight &#x3D; 600;<br> &#x2F;</em> Set size of world-coordinate clipping window. *&#x2F;<br> GLfloat xwcMin &#x3D; -450.0, xwcMax &#x3D; 450.0;<br> GLfloat ywcMin &#x3D; -300.0, ywcMax &#x3D; 300.0;</p>
<p> struct menuEntryStruct {<br>    const char* label;<br>     char key;</p>
<p> };</p>
<pre><code class="hljs">  static menuEntryStruct mainMenu[] = &#123; &quot;Reset&quot;, &#39;0&#39;,&quot;Create Bezier/Finish Bezier&quot;, &#39;1&#39;, &quot;Quit&quot;, 27,
      //ESC 键（ASCII: 27）
  &#125;;
</code></pre>
<p> int mainMenuEntries &#x3D; sizeof(mainMenu) &#x2F; sizeof(menuEntryStruct);</p>
<pre><code class="hljs"> bool globalControlPointsVisible = true;

 void userEventAction(int key) &#123;
 switch (key) &#123;
 case &#39;0&#39;:
     MyWorld.Empty();
     MyWorld.pickedObjectId = -1;
     MyState = MoveObject;
     break;
 case &#39;1&#39;: // bezier
      if (MyState == MoveObject)
         &#123;
         MyState = MakePoint;
         ++LineNum;
          &#125;
      else if (MyState == MakePoint)
         &#123;
          MyState = MoveObject;
        
             &#125;
 break;
 case 27: // ESC 键（ASCII: 27）退出
     MyWorld.Empty();
      exit(0);
      break;
 default:
     break;
    
 &#125;
  glutPostRedisplay(); // 重绘
</code></pre>
<p> }<br>     void keyboard(unsigned char key, int x, int y)<br>     {<br>         userEventAction(key);<br>     }<br>     void selectMain(int choice) &#x2F;&#x2F; 序号-&gt;key 映射<br>     {<br>         userEventAction(mainMenu[choice].key); &#x2F;&#x2F; 调用通用动作解释函数<br>     }<br>     void displayFcn(void)<br>          {<br>          glClear(GL_COLOR_BUFFER_BIT); &#x2F;&#x2F; Clear display window.<br>          for (int i &#x3D; 1; i &lt;&#x3D; LineNum;i++)MyBezier[i].Draw();<br>         glFlush();<br>         }</p>
<pre><code class="hljs"> void unProject(GLdouble winx, GLdouble winy, GLdouble winz, GLdouble* objx, GLdouble* objy, GLdouble*objz)
     &#123;
      // 从窗口到世界坐标系
          GLint viewport[4];
     GLdouble modelview[16];
      GLdouble projection[16];
     glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
      glGetDoublev(GL_PROJECTION_MATRIX, projection);
      glGetIntegerv(GL_VIEWPORT, viewport);
      gluUnProject(winx, winy, winz, modelview, projection, viewport
         , objx, objy, objz);
      &#125;
 
      void mouseButton(int button, int state, int x, int y)
      &#123;
      switch (button) &#123;
      case GLUT_LEFT_BUTTON:
         break;
      default:
         return;
        
     &#125;
     switch (state) &#123;
     case GLUT_DOWN:
         if (MyState == MoveObject)
              &#123;
              MyWorld.PickObject(x, y);
              printf(&quot;MyWorld.pickedObjectId: %d\n&quot;,MyWorld.pickedObjectId);
             &#125;
     else if (MyState == MakePoint)
             &#123;
            if  (GLPoint* ptr = MyWorld.objects[MyWorld.pickedObjectId])
                 &#123;
                // 从窗口到世界坐标系
                     GLdouble winx = (GLdouble)x;
                 GLdouble winy = (GLdouble)winHeight - (GLdouble)
                     y;
                GLdouble winz = 0;
                  GLdouble objx = 0;
                 GLdouble objy = 0;
                 GLdouble objz = 0;
                  unProject(winx, winy, winz, &amp;objx, &amp;objy, &amp;objz);
                 MyBezier[LineNum].parentWorld = &amp;MyWorld;
                  MyBezier[LineNum].MakePoint(objx, objy, objz);
                
                     &#125;
             &#125;
         break;
     case GLUT_UP:
          glutPostRedisplay();
         break;
        
     &#125;
     &#125;

      void mouseMotion(int x, int y)
         &#123;
          if (MyWorld.pickedObjectId == -1) return;
          if (!MyWorld.objects[MyWorld.pickedObjectId]-&gt;movable) return;
         
             GLPoint * ptr = MyWorld.objects[MyWorld.pickedObjectId];
         
             // 从窗口到世界坐标系
              GLdouble winx = (GLdouble)x;
           GLdouble winy = (GLdouble)winHeight - (GLdouble)y;
          GLdouble winz = 0;
           GLdouble objx = 0;
          GLdouble objy = 0;
          GLdouble objz = 0;
           unProject(winx, winy, winz, &amp;objx, &amp;objy, &amp;objz);
          
              ptr-&gt;SetPosition(objx, objy, objz);
         
               glutPostRedisplay();
          &#125;
      void init(void)
      &#123;
          glClearColor(1.0, 1.0, 1.0, 0.0); // Set display-window color to white.
          glMatrixMode(GL_PROJECTION);
          glutCreateMenu(selectMain);
          glutCreateMenu(selectMain); // 使用 selectMain 作为菜单调用函数
          for (int i = 0; i &lt; mainMenuEntries; i++) &#123;
              glutAddMenuEntry(mainMenu[i].label, i);

          &#125;
          glutAttachMenu(GLUT_RIGHT_BUTTON); // 菜单绑定右键
          gluOrtho2D(xwcMin, xwcMax, ywcMin, ywcMax);
      &#125;

      void display(void)
      &#123;
          glClear(GL_COLOR_BUFFER_BIT); // Clear display window.
          for (int i = 1; i &lt;= LineNum; i++)
              MyBezier[i].Draw();
          glFlush();
      &#125;

      void reshape(int newWidth, int newHeight)
      &#123;
          glViewport(0, 0, newWidth, newHeight);
          winWidth = newWidth;
          winHeight = newHeight;
      &#125;

      void winReshapeFcn(int newWidth, int newHeight)
      &#123;
          if (newWidth &gt; newHeight)
              glViewport((newWidth - newHeight) / 2, 0, newHeight, newHeight);
          else
              glViewport(0, (newHeight - newWidth) / 2, newWidth, newWidth);

          glMatrixMode(GL_PROJECTION);
          glLoadIdentity();
          gluOrtho2D(xwcMin, xwcMax, ywcMin, ywcMax);
      &#125;

      void menuFcn(int value)
      &#123;
          userEventAction(mainMenu[value].key);
      &#125;

      void createMenu()
      &#123;
          int menu = glutCreateMenu(menuFcn);
          for (int i = 0; i &lt; mainMenuEntries; i++)
          &#123;
              glutAddMenuEntry(mainMenu[i].label, i);
          &#125;
          glutAttachMenu(GLUT_RIGHT_BUTTON);
      &#125;

      int main(int argc, char** argv)
      &#123;
          glutInit(&amp;argc, argv);
          glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
          glutInitWindowPosition(100, 100);
          glutInitWindowSize(winWidth, winHeight);
          glutCreateWindow(&quot;My World&quot;);

          init();
          glutDisplayFunc(display);
          glutReshapeFunc(winReshapeFcn);
          glutMouseFunc(mouseButton);
          glutMotionFunc(mouseMotion);
          glutKeyboardFunc(keyboard);
          glutMainLoop();
          return 0;
      &#125;
</code></pre>
<p>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;*<br>&#x2F;&#x2F;* ###############OpenGL绘制贝塞尔曲线(Bézier_curve)###############<br>&#x2F;&#x2F;*<br>&#x2F;&#x2F;* 说明：<br>&#x2F;&#x2F;* 主要参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41856733/article/details/85309521">https://blog.csdn.net/qq_41856733/article/details/85309521</a><br>&#x2F;&#x2F;* GL相关函数可参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/opengl/gllinestipple">https://docs.microsoft.com/zh-cn/windows/win32/opengl/gllinestipple</a><br>&#x2F;&#x2F;* vs2019配置OpenGL可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41894030/article/details/100381865">https://blog.csdn.net/weixin_41894030/article/details/100381865</a><br>&#x2F;&#x2F;* 如有侵权行为或其他不当之处欢迎联系作者：<a href="mailto:&#50;&#56;&#x30;&#51;&#49;&#54;&#x38;&#54;&#52;&#x39;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#50;&#56;&#x30;&#51;&#49;&#54;&#x38;&#54;&#52;&#x39;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a><br>&#x2F;&#x2F;<em>&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;#include &lt;windows.h&gt;<br>&#x2F;&#x2F;#include &lt;GL&#x2F;glut.h&gt;<br>&#x2F;&#x2F;#include &lt;math.h&gt;<br>&#x2F;&#x2F;#include &lt;stdio.h&gt;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;#define    MAXPOINTS    20<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;int</em> C;&#x2F;&#x2F;二项式系数数组指针<br>&#x2F;&#x2F;int control_points_n &#x3D; 0;&#x2F;&#x2F;控制点数量<br>&#x2F;&#x2F;int specific_p;&#x2F;&#x2F;特定点标志<br>&#x2F;&#x2F;int click_state &#x3D; 0;&#x2F;&#x2F;0为新增控制点，1为移动控制点，2为已到底控制点最大值<br>&#x2F;&#x2F;int screen_width, screen_height;&#x2F;&#x2F;屏幕宽度，长度<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;struct point<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int x;<br>&#x2F;&#x2F;    int y;<br>&#x2F;&#x2F;};<br>&#x2F;&#x2F;point* P;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;函数声明<br>&#x2F;&#x2F;void reshape(int w, int h);&#x2F;&#x2F;自适应屏幕窗口大小的改变<br>&#x2F;&#x2F;void keyboard(unsigned char button, int x, int y);&#x2F;&#x2F;控制按键函数<br>&#x2F;&#x2F;void mouse_click(int button, int state, int x, int y);&#x2F;&#x2F;处理鼠标click事件函数<br>&#x2F;&#x2F;void mouse_motion(int x, int y);&#x2F;&#x2F;鼠标在窗口中按下并移动时调用此函数<br>&#x2F;&#x2F;void display(void);&#x2F;&#x2F;显示函数,需要显示时调用此函数<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;定位坐标函数<br>&#x2F;&#x2F;void gotoxy(int x, int y) {<br>&#x2F;&#x2F;    COORD coord;<br>&#x2F;&#x2F;    coord.X &#x3D; x;<br>&#x2F;&#x2F;    coord.Y &#x3D; y;<br>&#x2F;&#x2F;    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;int main(int argc, char** argv)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    P &#x3D; new point[MAXPOINTS];&#x2F;&#x2F;控制点数组指针<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    printf(“按下&quot;ESC&quot;键退出。按下&quot;R&quot;键重新绘制\r\n”);<br>&#x2F;&#x2F;    printf(“最多添加20个点”);<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    glutInit(&amp;argc, argv);&#x2F;&#x2F;gult初始化<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;<em>在创建窗口的时候，指定其显示模式的类型。GLUT_DOUBLE代表双缓冲<br>&#x2F;&#x2F;    详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangyong0717/article/details/78003913">https://blog.csdn.net/yangyong0717/article/details/78003913</a></em>&#x2F;<br>&#x2F;&#x2F;    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);<br>&#x2F;&#x2F;    glutInitWindowPosition(100, 100);&#x2F;&#x2F;初始化窗口距离屏幕左边和上面的像素数<br>&#x2F;&#x2F;    glutInitWindowSize(500, 500);&#x2F;&#x2F;初始化窗口宽度和高度<br>&#x2F;&#x2F;    glutCreateWindow(“Bézier curve”);&#x2F;&#x2F;创建窗口，”Bézier curve”为窗口名字<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;清除颜色缓冲区,防止缓冲区中原有的颜色信息影响本次绘图<br>&#x2F;&#x2F;    &#x2F;&#x2F;详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/jennifer111111/article/details/51649153">https://blog.csdn.net/jennifer111111/article/details/51649153</a><br>&#x2F;&#x2F;    glClearColor(1.0, 1.0, 1.0, 1.0);<br>&#x2F;&#x2F;    glEnable(GL_LINE_STIPPLE);&#x2F;&#x2F;启用直线点画功能<br>&#x2F;&#x2F;    glutReshapeFunc(reshape);&#x2F;&#x2F;若屏幕窗口大小改变则调用reshape函数<br>&#x2F;&#x2F;    glutKeyboardFunc(keyboard);&#x2F;&#x2F;处理普通按键消息。详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/xie_zi/article/details/1911891">https://blog.csdn.net/xie_zi/article/details/1911891</a><br>&#x2F;&#x2F;    glutMouseFunc(mouse_click);&#x2F;&#x2F;处理鼠标click事件<br>&#x2F;&#x2F;    glutMotionFunc(mouse_motion);&#x2F;&#x2F;当鼠标在窗口中按下并移动时调用glutMotionFunc注册的回调函数<br>&#x2F;&#x2F;    glutDisplayFunc(display);&#x2F;&#x2F;当窗口内容被绘制时调用display函数<br>&#x2F;&#x2F;    glutMainLoop();&#x2F;&#x2F;进入gult死循环<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    delete[] P;<br>&#x2F;&#x2F;    return 1;<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;画正方形，用来标记点<br>&#x2F;&#x2F;void Draw_Square(int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    glColor3f(0, 1, 0);&#x2F;&#x2F;设置颜色，三个参数分别代表red, green, blue<br>&#x2F;&#x2F;    glBegin(GL_POLYGON);&#x2F;&#x2F;绘制了一个凸多边形。顶点1到n定义了这个多边形。<br>&#x2F;&#x2F;    glVertex2f(x + 2, y + 2);<br>&#x2F;&#x2F;    glVertex2f(x - 2, y + 2);<br>&#x2F;&#x2F;    glVertex2f(x - 2, y - 2);<br>&#x2F;&#x2F;    glVertex2f(x + 2, y - 2);<br>&#x2F;&#x2F;    glEnd();<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;<em>计算二项式系数<br>&#x2F;&#x2F;</em> n为次数，C为存放二项式系数的数组<br>&#x2F;&#x2F;* 利用了C(n-k)(n)&#x3D;C(k)(n)<br>&#x2F;&#x2F;* 即C[k] &#x3D; C(k)(n),k在右上角，n在左下角（不知道怎么打那个符号。。）*&#x2F;<br>&#x2F;&#x2F;void Culculate_Binomial_Coefficient(int n, int* C)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int k, j;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    for (k &#x3D; 0;k &lt;&#x3D; n;k++)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        C[k] &#x3D; 1;<br>&#x2F;&#x2F;        for (j &#x3D; n;j &gt;&#x3D; k + 1;j–)&#x2F;&#x2F;1<em>n</em>(n-1)<em>(n-2)</em>…<em>(k+2)</em>(k+1)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            C[k] <em>&#x3D; j;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        for (j &#x3D; n - k;j &gt;&#x3D; 2;j–)&#x2F;&#x2F;上式 &#x2F; ( (n-k)</em>(n-k-1)<em>…<em>3</em>2</em>1 )<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            C[k] &#x2F;&#x3D; j;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;画贝塞尔曲线<br>&#x2F;&#x2F;&#x2F;&#x2F;n为维度（即控制点数减1），p为控制点数组，m为密度<br>&#x2F;&#x2F;void Draw_Bézier_curve(int n, point* p, int m)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int i, j;<br>&#x2F;&#x2F;    float t;<br>&#x2F;&#x2F;    int C[MAXPOINTS - 1];&#x2F;&#x2F;二项式系数数组。这样定义有些浪费空间，但不知道更好的办法<br>&#x2F;&#x2F;    &#x2F;&#x2F;算出来的曲线轨迹点x坐标。用float型相比int型曲线会更平滑<br>&#x2F;&#x2F;    float Bézier_curve_pointx;<br>&#x2F;&#x2F;    float Bézier_curve_pointy;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    Culculate_Binomial_Coefficient(n, C);<br>&#x2F;&#x2F;    glLineStipple(1, 0xffff);&#x2F;&#x2F;设置为实线<br>&#x2F;&#x2F;    glBegin(GL_LINE_STRIP);<br>&#x2F;&#x2F;    &#x2F;&#x2F;这里实际上是画了m条短直线来接近贝塞尔曲线<br>&#x2F;&#x2F;    for (i &#x3D; 0;i &lt;&#x3D; m;i++)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        t &#x3D; (float)i &#x2F; (float)m;<br>&#x2F;&#x2F;        Bézier_curve_pointx &#x3D; 0;<br>&#x2F;&#x2F;        Bézier_curve_pointy &#x3D; 0;<br>&#x2F;&#x2F;        for (j &#x3D; 0;j &lt; control_points_n;j++)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            Bézier_curve_pointx +&#x3D; C[j] * pow(1 - t, control_points_n - j - 1) * pow(t, j) * p[j].x;<br>&#x2F;&#x2F;            Bézier_curve_pointy +&#x3D; C[j] * pow(1 - t, control_points_n - j - 1) * pow(t, j) * p[j].y;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        glVertex2f(Bézier_curve_pointx, Bézier_curve_pointy);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    glEnd();<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;自适应屏幕窗口大小的改变<br>&#x2F;&#x2F;&#x2F;&#x2F;关于reshape函数可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41856733/article/details/85309521">https://blog.csdn.net/qq_41856733/article/details/85309521</a><br>&#x2F;&#x2F;void reshape(int w, int h)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    screen_width &#x3D; w;<br>&#x2F;&#x2F;    screen_height &#x3D; h;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    glViewport(0, 0, w, h);<br>&#x2F;&#x2F;    glMatrixMode(GL_PROJECTION);<br>&#x2F;&#x2F;    glLoadIdentity();<br>&#x2F;&#x2F;    gluOrtho2D(0.0, w, 0.0, h);<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;控制按键函数<br>&#x2F;&#x2F;void keyboard(unsigned char button, int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    switch (button)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;    case 82:&#x2F;&#x2F;“R”<br>&#x2F;&#x2F;    case 114:&#x2F;&#x2F;“r”<br>&#x2F;&#x2F;        &#x2F;&#x2F;重新绘图<br>&#x2F;&#x2F;        &#x2F;&#x2F;清空之前显示的坐标<br>&#x2F;&#x2F;        gotoxy(0, 3);<br>&#x2F;&#x2F;        for (int i &#x3D; 0;i &lt; control_points_n;i++)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            printf(“                   \r\n”);<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;        specific_p &#x3D; control_points_n &#x3D; 0;<br>&#x2F;&#x2F;        click_state &#x3D; 0;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;        &#x2F;*glutPostRedisplay函数用来标记当前窗口需要重新绘制。通过glutMainLoop<br>&#x2F;&#x2F;        * 下一次循环时，窗口显示将被回调以重新显示窗口的正常面板*&#x2F;<br>&#x2F;&#x2F;        glutPostRedisplay();<br>&#x2F;&#x2F;        break;<br>&#x2F;&#x2F;    case 27:&#x2F;&#x2F;“ESC”<br>&#x2F;&#x2F;        exit(0);&#x2F;&#x2F;退出glut循环<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;*<br>&#x2F;&#x2F;* 处理鼠标click事件函数<br>&#x2F;&#x2F;* button表明哪个鼠标键被按下或松开,第二个参数表明函数被调用发生时鼠标的<br>&#x2F;&#x2F;* 状态（按下或松开），x,y表示鼠标在当前窗口的坐标（以左上角为原点）<br>&#x2F;&#x2F;*&#x2F;<br>&#x2F;&#x2F;void mouse_click(int button, int state, int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int i;<br>&#x2F;&#x2F;    int distance;&#x2F;&#x2F;鼠标点击处于任意一点距离<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;如果鼠标左键按下<br>&#x2F;&#x2F;    if (button &#x3D;&#x3D; GLUT_LEFT_BUTTON)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        &#x2F;&#x2F;不是移动状态时计算距离<br>&#x2F;&#x2F;        if (state &#x3D;&#x3D; GLUT_DOWN &amp;&amp; click_state !&#x3D; 1)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            for (i &#x3D; 0;i &lt; control_points_n;i++)<br>&#x2F;&#x2F;            {<br>&#x2F;&#x2F;                &#x2F;&#x2F;按控制点依次计算距离<br>&#x2F;&#x2F;                distance &#x3D; (x - P[i].x) * (x - P[i].x) +<br>&#x2F;&#x2F;                    (screen_height - y - P[i].y) * (screen_height - y - P[i].y);<br>&#x2F;&#x2F;                if (distance &lt; 15)&#x2F;&#x2F;如果距离小于特定值<br>&#x2F;&#x2F;                {<br>&#x2F;&#x2F;                    click_state &#x3D; 1;&#x2F;&#x2F;进入状态1，即移动点<br>&#x2F;&#x2F;                    specific_p &#x3D; i;<br>&#x2F;&#x2F;                    break;&#x2F;&#x2F;跳出循环<br>&#x2F;&#x2F;                }<br>&#x2F;&#x2F;            }<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;        if (state &#x3D;&#x3D; GLUT_DOWN &amp;&amp; click_state &#x3D;&#x3D; 0)&#x2F;&#x2F;新增点<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            if (control_points_n &lt; MAXPOINTS)<br>&#x2F;&#x2F;            {<br>&#x2F;&#x2F;                P[control_points_n].x &#x3D; x;<br>&#x2F;&#x2F;                P[control_points_n].y &#x3D; screen_height - y;<br>&#x2F;&#x2F;                specific_p &#x3D; control_points_n;<br>&#x2F;&#x2F;                control_points_n++;<br>&#x2F;&#x2F;                glutPostRedisplay();<br>&#x2F;&#x2F;            }<br>&#x2F;&#x2F;            else click_state &#x3D; 2;&#x2F;&#x2F;进入状态2，无法新增控制点<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        else if (state &#x3D;&#x3D; GLUT_DOWN &amp;&amp; click_state &#x3D;&#x3D; 1)&#x2F;&#x2F;移动点<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            P[specific_p].x &#x3D; x;<br>&#x2F;&#x2F;            P[specific_p].y &#x3D; screen_height - y;<br>&#x2F;&#x2F;            glutPostRedisplay();<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;        else if (state &#x3D;&#x3D; GLUT_UP)<br>&#x2F;&#x2F;        {<br>&#x2F;&#x2F;            &#x2F;&#x2F;判断控制点是否已达上限<br>&#x2F;&#x2F;            click_state &#x3D; control_points_n &lt; MAXPOINTS ? 0 : 2;<br>&#x2F;&#x2F;        }<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;鼠标在窗口中按下并移动时调用此函数<br>&#x2F;&#x2F;void mouse_motion(int x, int y)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    if (click_state &#x3D;&#x3D; 1)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        P[specific_p].x &#x3D; x;<br>&#x2F;&#x2F;        P[specific_p].y &#x3D; screen_height - y;<br>&#x2F;&#x2F;        glutPostRedisplay();<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F;&#x2F;显示函数,需要显示时调用此函数<br>&#x2F;&#x2F;void display(void)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    int i;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    glClear(GL_COLOR_BUFFER_BIT);&#x2F;&#x2F;清缓存。GL_COLOR_BUFFER_BIT代表当前可写的颜色缓冲<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    for (i &#x3D; 0;i &lt; control_points_n;i++)&#x2F;&#x2F;画控制点<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        Draw_Square(P[i].x, P[i].y);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    &#x2F;&#x2F;显示控制点坐标<br>&#x2F;&#x2F;    gotoxy(0, specific_p + 3);<br>&#x2F;&#x2F;    printf(“P%d:(%d, %d)  “, specific_p, P[specific_p].x, P[specific_p].y);<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;0x0f0f即0000 1111 0000 1111，即黑白等长的虚线<br>&#x2F;&#x2F;    &#x2F;&#x2F;glLineStipple函数详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/oktears/article/details/42262187">https://blog.csdn.net/oktears/article/details/42262187</a><br>&#x2F;&#x2F;    glLineStipple(1, 0x0f0f);<br>&#x2F;&#x2F;    glBegin(GL_LINE_STRIP);&#x2F;&#x2F;启用直线点画功能<br>&#x2F;&#x2F;    glColor3f(1, 0, 0);&#x2F;&#x2F;设置颜色，三个参数分别代表red, green, blue<br>&#x2F;&#x2F;    for (i &#x3D; 0;i &lt; control_points_n;i++)&#x2F;&#x2F;画虚线<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        glVertex2f(P[i].x, P[i].y);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    glEnd();<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    if (control_points_n &gt; 1)&#x2F;&#x2F;有大于1个控制点就画出贝塞尔曲线<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        Draw_Bézier_curve(control_points_n - 1, P, 200);<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;    &#x2F;&#x2F;函数详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012442207/article/details/45223261">https://blog.csdn.net/u012442207/article/details/45223261</a><br>&#x2F;&#x2F;    glutSwapBuffers();&#x2F;&#x2F;交换两个缓冲区指针<br>&#x2F;&#x2F;}<br>“</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Opengl 的贝塞尔曲线绘制</div>
      <div>http://example.com/2023/11/20/index/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>CrushYouX</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/16/hexo-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%BF%83%E5%BE%97/" title="hexo">
                        <span class="hidden-mobile">hexo</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"WAQyDRcuzrK2cZjVhUWaqfpC-gzGzoHsz","appKey":"Lf7r7JrEwvMcsBEeb3KngwSY","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量
        <span id="leancloud-site-pv"></span>
        次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数
        <span id="leancloud-site-uv"></span>
        人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
